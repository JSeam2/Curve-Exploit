// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import {Exploit, IERC20, ICurvePool} from "../src/Exploit.sol";

contract CounterTest is Test {
    Exploit public exploit;
    ICurvePool curvepool = ICurvePool(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);

    fallback() external payable {}

    function setUp() public {
        exploit = new Exploit(address(this));
    }

    // function testExploit() public {
    //     IERC20[] memory ierc20array = new IERC20[](1);
    //     ierc20array[0] = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    //     uint256[] memory amountsArray = new uint256[](1);
    //     amountsArray[0] = 80000000000000000000000;

    //     exploit.makeFlashLoan(
    //         ierc20array, // WETH address
    //         amountsArray, // 80k eth
    //         ""
    //     );
    // }

    // function testRemoveLiquidity() public {
    //     // uint256[2] memory _amounts;
    //     // _amounts[0] = 1000000000000;
    //     // _amounts[1] = 0;
    //     // uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0, address(this));

    //     uint256 mintAmount = curvepool.balanceOf(address(this));
    //     uint256[2] memory _min_amounts;
    //     _min_amounts[0] = 0;
    //     _min_amounts[1] = 0;
    //     curvepool.remove_liquidity(mintAmount, _min_amounts, address(this));
    // }

    // function testAddLiquidity() public {

    //     uint256[2] memory _amounts;
    //     _amounts[0] = 1000000000000;
    //     _amounts[1] = 0;
    //     uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0, address(this));

    //     uint256 peth_eth_balance = curvepool.balanceOf(address(this));
    //     assertEq(mintAmount, peth_eth_balance);

    //     // uint256[2] memory _min_amounts;
    //     // _min_amounts[0] = 0;
    //     // _min_amounts[1] = 0;
    //     // curvepool.remove_liquidity(peth_eth_balance, _min_amounts, address(this));
    // }

    function testAddRemoveLiquidity() public {

        uint256[2] memory _amounts;
        _amounts[0] = 1000000000000;
        _amounts[1] = 0;
        uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0, address(this));

        uint256 peth_eth_balance = curvepool.balanceOf(address(this));
        assertEq(mintAmount, peth_eth_balance);

        uint256[2] memory _min_amounts;
        _min_amounts[0] = 0;
        _min_amounts[1] = 0;
        curvepool.remove_liquidity(peth_eth_balance, _min_amounts, address(this));
    }

}
