// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import "forge-std/Vm.sol";
import {Exploit, IERC20, ICurvePool} from "../src/Exploit.sol";

contract CounterTest is Test {
    Exploit public exploit;
    ICurvePool curvepool = ICurvePool(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);
    IERC20 peth = IERC20(0x836A808d4828586A69364065A1e064609F5078c7);

    fallback() external payable {}

    function setUp() public {
        exploit = new Exploit(address(this));
        // bytes memory code = address(exploit).code;
        // address targetAddr = makeAddr("target");
        // vm.etch(targetAddr, code);
        // emit log_bytes(address(targetAddr).code);
        vm.deal(address(this), 1000000000 ether);
        vm.deal(address(exploit), 1000000000 ether);
        console2.log("test contract address", address(this));
        console2.log("test contract eth balance", address(this).balance);
        console2.log("exploit contract address", address(exploit));
        console2.log("exploit contract eth balance", address(exploit).balance);
    }

    // function testExploit() public {
    //     exploit.makeFlashLoan();
    // }

    // function testExploit2() public {
    //     // address(exploit).call.value(1 ether).gas(30_000_000)();
    //     (bool sent,) = address(exploit).call{value: 1 ether, gas: 30_000_000}("");
    //     require(sent);
    // }

    // Test adding liquidity to the curve pool
    // function testAddLiquidity() public {
    //     uint256[2] memory _amounts;
    //     _amounts[0] = 1000000000000;
    //     _amounts[1] = 0;
    //     uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0, address(this));

    //     console2.log("mintAmount=", mintAmount);

    //     uint256 peth_eth_balance = curvepool.balanceOf(address(this));
    //     assertEq(mintAmount, peth_eth_balance);
    // }


    // Test removing liquidity to the curve pool
    // function testRemoveLiquidity() public {
    //     uint256 mintAmount = curvepool.balanceOf(address(this));
    //     console2.log("lp token balance=", mintAmount);
    //     uint256[2] memory _min_amounts;
    //     _min_amounts[0] = 0;
    //     _min_amounts[1] = 0;
    //     curvepool.remove_liquidity(mintAmount, _min_amounts);
    // }

    // Test adding liquidty liquidity and removing liquidity
    // function test_AddRemoveLiquidityOneCoin() public {
    //     uint256[2] memory _amounts;
    //     _amounts[0] = 1000000000000;
    //     _amounts[1] = 0;
    //     uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0);

    //     uint256 peth_eth_balance = curvepool.balanceOf(address(this));
    //     console2.log("lp token balance=", peth_eth_balance);
    //     console2.log("peth balance=", peth.balanceOf(address(this)));
    //     console2.log("ETH balance=", address(this).balance);
    //     assertEq(mintAmount, peth_eth_balance);

    //     uint256[2] memory _min_amounts;
    //     _min_amounts[0] = 0;
    //     _min_amounts[1] = 0;
    //     curvepool.approve(address(curvepool), peth_eth_balance);

    //     assertTrue(curvepool.allowance(address(this), address(curvepool)) == peth_eth_balance);

    //     uint256 res = curvepool.remove_liquidity_one_coin(peth_eth_balance, 0, 0);
    //     console2.log("res=", res);
    //     peth_eth_balance = curvepool.balanceOf(address(this));
    //     console2.log("lp token balance=", peth_eth_balance);

    //     assertTrue(curvepool.balanceOf(address(this)) == 0);

    //     console2.log("pETH balance=", peth.balanceOf(address(this)));
    //     console2.log("ETH balance=", address(this).balance);
    // }

    // Test adding liquidty liquidity and removing liquidity
    function test_AddRemoveLiquidity() public {
        uint256[2] memory _amounts;
        _amounts[0] = 1000000000000;
        _amounts[1] = 0;
        uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0);

        uint256 peth_eth_balance = curvepool.balanceOf(address(this));
        console2.log("lp token balance=", peth_eth_balance);
        console2.log("peth balance=", peth.balanceOf(address(this)));
        console2.log("ETH balance=", address(this).balance);
        assertEq(mintAmount, peth_eth_balance);

        uint256[2] memory _min_amounts;
        _min_amounts[0] = uint256(0);
        _min_amounts[1] = uint256(0);
        curvepool.approve(address(curvepool), peth_eth_balance);

        assertTrue(curvepool.allowance(address(this), address(curvepool)) == peth_eth_balance);
        console2.log("allowance=", curvepool.allowance(address(this), address(curvepool)));

        uint256[] memory res = curvepool.remove_liquidity(peth_eth_balance, _min_amounts);
        console2.log("res0=", res[0]);
        console2.log("res1=", res[1]);
        peth_eth_balance = curvepool.balanceOf(address(this));
        console2.log("lp token balance=", peth_eth_balance);

        assertTrue(curvepool.balanceOf(address(this)) == 0);

        console2.log("pETH balance=", peth.balanceOf(address(this)));
        console2.log("ETH balance=", address(this).balance);
    }
}
