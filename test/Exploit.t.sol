// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import {Exploit, IERC20, ICurvePool} from "../src/Exploit.sol";

contract CounterTest is Test {
    Exploit public exploit;
    ICurvePool curvepool = ICurvePool(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);

    fallback() external payable {}

    function setUp() public {
        exploit = new Exploit(address(this));
    }

    // function testExploit() public {
    //     exploit.makeFlashLoan{gas: 1000000000000000000}();
    // }

    function testExploit2() public {
        // address(exploit).call.value(1 ether).gas(30_000_000)();
        (bool sent,) = address(exploit).call{value: 1 ether, gas: 30_000_000}("");
        require(sent);
    }

    // Test adding liquidity to the curve pool
    // function testAddLiquidity() public {
    //     uint256[2] memory _amounts;
    //     _amounts[0] = 1000000000000;
    //     _amounts[1] = 0;
    //     uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0, address(this));

    //     console2.log("mintAmount=", mintAmount);

    //     uint256 peth_eth_balance = curvepool.balanceOf(address(this));
    //     assertEq(mintAmount, peth_eth_balance);
    // }


    // Test removing liquidity to the curve pool
    // function testRemoveLiquidity() public {
    //     uint256 mintAmount = curvepool.balanceOf(address(this));
    //     console2.log("lp token balance=", mintAmount);
    //     uint256[2] memory _min_amounts;
    //     _min_amounts[0] = 0;
    //     _min_amounts[1] = 0;
    //     curvepool.remove_liquidity(mintAmount, _min_amounts, address(this));
    // }

    // Test adding liquidty liquidity and removing liquidity
    // This should fail as it triggers the reentrancy lock
    // function testFail_AddRemoveLiquidity() public {
    //     uint256[2] memory _amounts;
    //     _amounts[0] = 1000000000000;
    //     _amounts[1] = 0;
    //     uint256 mintAmount = curvepool.add_liquidity{value: 1000000000000}(_amounts, 0, address(this));

    //     uint256 peth_eth_balance = curvepool.balanceOf(address(this));
    //     console2.log("lp token balance=", peth_eth_balance);
    //     assertEq(mintAmount, peth_eth_balance);

    //     // this should fail if not calling in succession
    //     uint256[2] memory _min_amounts;
    //     _min_amounts[0] = 0;
    //     _min_amounts[1] = 0;
    //     curvepool.approve(address(curvepool), peth_eth_balance);
    //     assertTrue(curvepool.allowance(address(this), address(curvepool)) == peth_eth_balance);
    //     curvepool.remove_liquidity(peth_eth_balance - 100000000000, _min_amounts, address(this));
    // }

}
